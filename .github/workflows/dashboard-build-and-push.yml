name: Build and Push Dashboard Images

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  AWS_REGION: ${{ vars.AWS_REGION }}
  ECR_REPOSITORY_PREFIX: ${{ vars.ECR_REPOSITORY_PREFIX }}
  DASHBOARD_INSTANCE_NAME: ${{ vars.DASHBOARD_INSTANCE_NAME }}

jobs:
  build-dashboard:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    strategy:
      matrix:
        include:
          - id: terraform-client
            context: lab-dashboard/backend/terraform-client
            dockerfile: lab-dashboard/backend/terraform-client/Dockerfile
            module: terraform-client
            prebuild: maven
          - id: chaos-injector
            context: lab-dashboard/backend/chaos-injector
            dockerfile: lab-dashboard/backend/chaos-injector/Dockerfile
            module: chaos-injector
            prebuild: maven
          - id: log-streamer
            context: lab-dashboard/backend/log-streamer
            dockerfile: lab-dashboard/backend/log-streamer/Dockerfile
            module: log-streamer
            prebuild: maven
          - id: dashboard-frontend
            context: lab-dashboard/frontend
            dockerfile: lab-dashboard/frontend/Dockerfile
            prebuild: npm
            build_args: |
              VITE_LOG_STREAM_URL=/api/logs/stream
              VITE_LOG_STREAM_POST_URL=/api/logs
          - id: dashboard-gateway
            context: lab-dashboard/deploy/dashboard
            dockerfile: lab-dashboard/deploy/dashboard/gateway/Dockerfile
    defaults:
      run:
        shell: bash

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        id: aws
        uses: ./.github/actions/aws-setup
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}

      - name: Set up JDK 17
        if: matrix.prebuild == 'maven'
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven

      - name: Build backend artifact
        if: matrix.prebuild == 'maven'
        working-directory: lab-dashboard/backend
        run: mvn -pl ${{ matrix.module }} -am package -DskipTests

      - name: Set up Node.js
        if: matrix.prebuild == 'npm'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: npm
          cache-dependency-path: ${{ matrix.context }}/package-lock.json

      - name: Build frontend bundle
        if: matrix.prebuild == 'npm'
        working-directory: ${{ matrix.context }}
        run: npm ci && npm run build

      - name: Ensure ECR repository exists
        env:
          REGISTRY: ${{ steps.aws.outputs.registry || secrets.ECR_REGISTRY || vars.ECR_REGISTRY }}
          REPO_NAME: ${{ env.ECR_REPOSITORY_PREFIX }}-${{ matrix.id }}
        run: |
          if [[ -z "${REGISTRY}" ]]; then
            echo "::error::ECR registry not provided. Set repository variable ECR_REGISTRY or secret." >&2
            exit 1
          fi
          if [[ -z "${REPO_NAME}" ]]; then
            echo "::error::ECR repository prefix is not set." >&2
            exit 1
          fi
          aws ecr describe-repositories --repository-names "${REPO_NAME}" >/dev/null 2>&1 || \
            aws ecr create-repository --repository-name "${REPO_NAME}"

      - name: Build and push image
        env:
          REGISTRY: ${{ steps.aws.outputs.registry || secrets.ECR_REGISTRY || vars.ECR_REGISTRY }}
          IMAGE_TAG: ${{ github.sha }}
          PUSH_LATEST: ${{ github.ref == 'refs/heads/main' && 'true' || 'false' }}
          BUILD_ARGS: ${{ matrix.build_args || '' }}
        run: |
          if [[ -z "${REGISTRY}" ]]; then
            echo "::error::ECR registry not provided." >&2
            exit 1
          fi
          if [[ -z "${ECR_REPOSITORY_PREFIX}" ]]; then
            echo "::error::ECR repository prefix not provided." >&2
            exit 1
          fi

          REPO_NAME="${ECR_REPOSITORY_PREFIX}-${{ matrix.id }}"
          IMAGE_NAME="${REGISTRY}/${REPO_NAME}:${IMAGE_TAG}"

          build_args=()
          if [[ -n "${BUILD_ARGS}" ]]; then
            while IFS='=' read -r key value; do
              [[ -z "$key" ]] && continue
              build_args+=(--build-arg "$key=$value")
            done <<< "${BUILD_ARGS}"
          fi

          docker build \
            "${build_args[@]}" \
            --file "${{ matrix.dockerfile }}" \
            --tag "${IMAGE_NAME}" \
            --tag "${REGISTRY}/${REPO_NAME}:latest" \
            "${{ matrix.context }}"
          docker push "${IMAGE_NAME}"
          if [[ "${PUSH_LATEST}" == "true" ]]; then
            docker push "${REGISTRY}/${REPO_NAME}:latest"
          fi

      - name: Summarise image
        env:
          REGISTRY: ${{ steps.aws.outputs.registry || secrets.ECR_REGISTRY || vars.ECR_REGISTRY }}
        run: |
          REPO_NAME="${ECR_REPOSITORY_PREFIX}-${{ matrix.id }}"
          echo "Built and pushed ${REGISTRY}/${REPO_NAME}:${GITHUB_SHA}" >> "$GITHUB_STEP_SUMMARY"
          echo "Tag ${GITHUB_SHA} ready for deployment" >> "$GITHUB_STEP_SUMMARY"

  deploy-dashboard:
    needs: build-dashboard
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        id: aws
        uses: ./.github/actions/aws-setup
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}

      - name: Resolve dashboard instance ID
        id: dashboard
        env:
          NAME_TAG: ${{ env.DASHBOARD_INSTANCE_NAME }}
        run: |
          set -euo pipefail
          if [[ -z "${NAME_TAG}" ]]; then
            echo "::error::Set repository variable DASHBOARD_INSTANCE_NAME to the EC2 Name tag." >&2
            exit 1
          fi
          INSTANCE_IDS=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=${NAME_TAG}" "Name=instance-state-name,Values=running" \
            --query "Reservations[].Instances[].InstanceId" \
            --output text | tr '\r' '\n' | sed '/^$/d')
          INSTANCE_ID=$(printf '%s\n' "${INSTANCE_IDS}" | head -n1)
          if [[ -z "${INSTANCE_ID}" || "${INSTANCE_ID}" == "None" ]]; then
            echo "::error::Dashboard instance with tag ${NAME_TAG} not found or not running." >&2
            exit 1
          fi
          echo "instance_id=${INSTANCE_ID}" >> "${GITHUB_OUTPUT}"

      - name: Update dashboard services
        env:
          INSTANCE_ID: ${{ steps.dashboard.outputs.instance_id }}
          BRANCH: ${{ github.ref_name }}
        run: |
          set -euo pipefail
          if [[ -z "${INSTANCE_ID}" ]]; then
            echo "::error::Dashboard instance id not resolved." >&2
            exit 1
          fi

          COMMANDS=$(printf '%s\n' \
            "set -eu" \
            "su - ubuntu -c 'cd \"/opt/chaos-dashboard/app\" && git fetch --all --prune && git checkout ${BRANCH} && git reset --hard origin/${BRANCH}'" \
            "if [ -d \"/opt/chaos-dashboard/app/scripts\" ]; then rsync -a --delete /opt/chaos-dashboard/app/scripts/ /opt/chaos-dashboard/scripts/ && chown -R ubuntu:ubuntu /opt/chaos-dashboard/scripts; fi" \
            "if [ -d \"/opt/chaos-dashboard/app/infra\" ]; then rsync -a --delete /opt/chaos-dashboard/app/infra/ /opt/chaos-dashboard/infra/ && chown -R ubuntu:ubuntu /opt/chaos-dashboard/infra; fi" \
            "/opt/chaos-dashboard/scripts/static/update-dashboard-instance.sh --all-tag ${GITHUB_SHA}" \
          | jq -R -s 'split("\n")[:-1]')

          COMMAND_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --comment "chaos-dashboard deploy ${GITHUB_SHA}" \
            --instance-ids "${INSTANCE_ID}" \
            --parameters "commands=${COMMANDS}" \
            --query "Command.CommandId" \
            --output text)

          if [[ -z "${COMMAND_ID}" || "${COMMAND_ID}" == "None" ]]; then
            echo "::error::Failed to dispatch SSM command." >&2
            exit 1
          fi

          aws ssm wait command-executed --command-id "${COMMAND_ID}" --instance-id "${INSTANCE_ID}"
          aws ssm get-command-invocation --command-id "${COMMAND_ID}" --instance-id "${INSTANCE_ID}"
